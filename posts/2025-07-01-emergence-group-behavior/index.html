<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>2025 07 02 鸟群行为模拟 | Wandering in Dreams</title><meta name=keywords content><meta name=description content="涌现式群体行为模拟
link: 【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！
鱼群、人群、蜂群等的自然模拟，使用Boids算法。
算法逻辑
$$
\vec{V} = \Pi c_i \vec{v_i} 
$$其中，\(\vec{V}\)为最终向量，\(c_i\)为可调权重，\(\vec{v_i}\)为单规则向量。
我们有以下3条规则：
规则一：Cohesion, 向群体中心靠拢
目标：保持群体集聚。
行为：计算特定范围（通常为视野范围）内同伴的平均位置，然后产生一个朝向这个平均位置的驱动力。
规则二：Separation, 避免与同伴碰撞
目标：避免碰撞。
行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。
规则三：Alignment, 与同伴移动方向保持一致。
目标：与群体行动方向趋同。
行为：计算特定范围（通常为视野范围）内同伴的平均方向，然后调整方向来匹配平均方向。
算法实现

import numpy as np
import random
import matplotlib.pyplot as plt
import math
import statistics
import pygame

MAX_SPEED = 10.0
WEIGHT_COHESION = 1
WEIGHT_SEPARATION = 1
WEIGHT_ALIGNMENT = 1
WEIGHT_FORCE_AGAINST_WALL = 0
SOCIAL_DISTANCE = 20.0
FRAMERATE = 30

GRAY = (127, 127, 127)
WHITE = (255, 255, 255)

def cart2pol(x, y):
    rho = np.sqrt(x**2 + y**2)
    phi = math.degrees(np.arctan2(y, x))
    return((phi + 360) % 360, rho)

def pol2cart(phi, rho):
    x = rho * np.cos(math.radians(phi))
    y = rho * np.sin(math.radians(phi))
    return(x, y)

class EmergenceBehaviorDemo:
    class Unit:
        x = 0.0
        y = 0.0
        phi: float
        v = 0.0
        i: int
        def __init__(self, i):
            self.i = i
    
    class Playground:
        w = 1280.0
        h = 720.0
        def __init__(self):
            pass
    
    unit_index: int
    peasants: list[Unit]
    playground: Playground
    leader_id: int
    leader_walk_weight_of_previous_tick: float = 0.6
    plot_x: list[float]
    plot_y: list[float]
    
    def init_peasants(self, group_grid_width: int, playground: Playground, interval: float) -> list[Unit]:
        # Generate at the center of the playground
        
        class Center:
            x = playground.w/2
            y = playground.h/2
        
        class StartingCoord:
            x = Center.x - ((group_grid_width - 1) * interval / 2)
            y = Center.y - ((group_grid_width - 1) * interval / 2)
        
        self.unit_index = 0
        peasants = []
        for i in range(group_grid_width):
            for j in range(group_grid_width):
                new_unit = self.Unit(self.unit_index)
                new_unit.x = StartingCoord.x + (interval * i)
                new_unit.y = StartingCoord.y + (interval * j)
                new_unit.phi = random.random() * 360
                peasants.append(new_unit)
                self.unit_index += 1
        
        return peasants
    
    @classmethod            
    def print_peasants_coordinates(cls, l:list[Unit]):
        for unit in l:
            print(f&#34;Peasant {unit.i}: ({unit.x}, {unit.y}), v = {unit.v}&#34;)
        return
    
    @classmethod  
    def print_peasant_coordinates(cls, u:Unit):
        print(f&#34;Peasant {u.i}: ({u.x}, {u.y}), phi = {u.phi}° v = {u.v}&#34;)
        return
    
    @classmethod  
    def update_position(cls, u: Unit, p: Playground):
        u.x += u.v * math.cos(math.radians(u.phi)) 
        u.y += u.v * math.sin(math.radians(u.phi))
        u.x = u.x % p.w
        u.y = u.y % p.h
    
    @classmethod  
    def point_in_triangle(cls, p, t_1, t_2, t_3):
        # https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
        def sign(p_1, p_2, p_3):
            return (p_1[0] - p_3[0]) * (p_2[1] - p_3[1]) - (p_2[0] - p_3[0]) * (p_1[1] - p_3[1])

        d1 = sign(p, t_1, t_2)
        d2 = sign(p, t_2, t_3)
        d3 = sign(p, t_3, t_1)
        
        has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
        has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)
    
        return not (has_neg and has_pos)
    
    @classmethod  
    def get_distance(cls, p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
    
    def get_all_unit_in_eye_sight(self, u: Unit, fov: float = 90.0, social_distance: float = 20.0, view_distance: float = 300.0) -> list[Unit]:
        res = []
        vertex_1 = (u.x, u.y)
        vertex_2 = (u.x + math.cos(math.radians(u.phi+(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi+(fov / 2))) * view_distance)
        vertex_3 = (u.x + math.cos(math.radians(u.phi-(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi-(fov / 2))) * view_distance)
        
        # Now we have one triangle
        for peasant in self.peasants:
            if peasant.i == u.i:
                continue
            if self.point_in_triangle((peasant.x, peasant.y), vertex_1, vertex_2, vertex_3) or self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                res.append(peasant)
        
        return res
    
    def get_all_unit_nearby(self, u: Unit, fov: float = 90.0, social_distance: float = 50.0, view_distance: float = 300.0) -> list[Unit]:
        res = []
        
        # Now we have one triangle
        for peasant in self.peasants:
            if peasant.i == u.i:
                continue
            if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                res.append(peasant)
        
        return res
    
    @classmethod  
    def combine_force_list(cls, l_force: list, l_weight: list = []):
        final_force_cart = [0, 0]
        
        if len(l_weight) == 0:
            actual_weight = [1] * len(l_force)
        else:
            actual_weight = l_weight
        
        for i in range(len(l_force)):
            (x, y) = pol2cart(l_force[i][0], l_force[i][1])
            final_force_cart[0] += x * actual_weight[i]
            final_force_cart[1] += y * actual_weight[i]
        
        final_force_rad = cart2pol(final_force_cart[0], final_force_cart[1])
        
        return final_force_rad
    
    @classmethod  
    def distance_between_point_and_line(cls, _lv1, _lv2, _p):
        lv1 = np.array(_lv1)
        lv2 = np.array(_lv2)
        p = np.array(_p)
        return np.abs(np.cross(lv2-lv1, lv1-p)) / np.linalg.norm(lv2-lv1)
    
    @classmethod  
    def force_against_the_walls(cls, u: Unit, p: Playground):
        v1 = (0.0, 0.0)
        v2 = (0.0, p.h)
        v3 = (p.w, 0.0)
        v4 = (p.w, p.h)
        s = (u.x, u.y)
        c = 200.0
        
        # Wall 1 v1-v2
        d1 = cls.distance_between_point_and_line(v1, v2, s)
        f1 = (90.0, c / d1)
        # Wall 2 v1-v3
        d2 = cls.distance_between_point_and_line(v1, v3, s)
        f2 = (180.0, c / d2)
        # Wall 3 v4-v2
        d3 = cls.distance_between_point_and_line(v4, v2, s)
        f3 = (0.0, c / d3)
        # Wall 4 v4-v3
        d4 = cls.distance_between_point_and_line(v4, v3, s)
        f4 = (270.0, c / d4)
        
        force_against_the_walls_list = [f1, f2, f3, f4]
        force_against_the_walls = cls.combine_force_list(force_against_the_walls_list)
        
        return force_against_the_walls
    
    def find_peasant_with_id(self, i):
        for u in self.peasants:
            if u.i == i: return u
        raise Exception('no such id')
    
    def update_behavior(
        self, 
        cohesion_weight: float = WEIGHT_COHESION, 
        separation_weight: float = WEIGHT_SEPARATION,
        social_distance: float = SOCIAL_DISTANCE, 
        alignment_weight: float = WEIGHT_ALIGNMENT,
        force_against_wall_weight: float = WEIGHT_FORCE_AGAINST_WALL
    ):
        
        new_direction_list = []
        for peasant in self.peasants:
            
            peasants_in_view = self.get_all_unit_in_eye_sight(peasant)
            peasants_nearby = self.get_all_unit_nearby(peasant)
            
            # Calculate cohesion
            if len(peasants_nearby) == 0:
                cohesion_force = (0, 0)
            else:
                
                average_position_in_view = (
                    statistics.mean(map(lambda x: x.x, peasants_nearby)),
                    statistics.mean(map(lambda x: x.y, peasants_nearby))
                )
                (xs, ys) = pol2cart(peasant.phi, peasant.v)
                cohesion_force = cart2pol((average_position_in_view[0]-xs), (average_position_in_view[1]-ys))
                
            # Calculate Separation
            separation_force_list = []
            for u in self.peasants:
                if u.i == peasant.i:
                    continue
                if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                    c = -1 / math.sqrt((u.y - peasant.y)**2 + (u.x - peasant.x)**2)
                    (x, y) = ((u.x - peasant.x) * c, (u.y - peasant.y) * c)
                    new_force = cart2pol(x, y)
                    separation_force_list.append(new_force)
            
            if len(separation_force_list) == 0:
                separation_force = (0, 0)
            else:
                separation_force = self.combine_force_list(separation_force_list)
            
            # Calculate Alignment
            if len(peasants_in_view) == 0:
                alignment_force = (0, 0)
            else:
                average_movement_in_view = (
                    statistics.mean(map(lambda x: x.phi, peasants_in_view)),
                    statistics.mean(map(lambda x: x.v, peasants_in_view))
                )
                
                (xt, yt) = pol2cart(average_movement_in_view[0], average_movement_in_view[1])
                (xs, ys) = pol2cart(peasant.phi, peasant.v)
                
                alignment_force = cart2pol((xt-xs), (yt-ys))
            
            # Calculate force against the wall
            force_against_wall = self.force_against_the_walls(peasant, self.playground)
            
            cohesion_force = (cohesion_force[0], cohesion_force[1]**0.75)
            alignment_force = (alignment_force[0], math.sqrt(alignment_force[1]))
            
            total_force = self.combine_force_list(
                [cohesion_force, separation_force, alignment_force, force_against_wall],
                [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight]
            )
            
            if peasant.i == self.leader_id:
                print(f&#34;c_force:({cohesion_force[0]:.2f}°, {cohesion_force[1]:.2f}m/s) s_force:({separation_force[0]:.2f}°, {separation_force[1]:.2f}m/s) a_force:({alignment_force[0]:.2f}°, {alignment_force[1]:.2f}m/s) f_force:({force_against_wall[0]:.2f}°, {force_against_wall[1]:.2f}m/s)&#34;)
            
            new_direction_list.append((peasant.i, total_force))
            
        for (_i, (_phi, _v)) in new_direction_list:
            current_peasant = self.peasants[_i]
            current_peasant.phi = _phi
            current_peasant.v = min(_v, MAX_SPEED)
        
        for peasant in self.peasants:
            self.update_position(peasant, self.playground)
    
    def __init__(self, group_grid_width: int, interval: float):
        self.playground = self.Playground()
        self.peasants = self.init_peasants(group_grid_width, self.playground, interval)
        self.leader_id = random.randint(0, len(self.peasants)-1)
        self.plot_x = []
        self.plot_y = []
        pass

def pygame_rot_center(image, angle, x, y):
    
    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = image.get_rect(center = (x, y)).center)

    return rotated_image, new_rect

def main():
    run = True
    
    game = EmergenceBehaviorDemo(7, 10.0)
    
    pygame.init()
    window = pygame.display.set_mode((game.playground.w, game.playground.h))
    clock = pygame.time.Clock()
    
    pygame_image_fish = pygame.image.load('fish.png').convert_alpha()
    
    
    while run:
        clock.tick(FRAMERATE)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
        
        game.update_behavior()

        window.fill(GRAY)
        for peasant in game.peasants:
            if peasant.i == game.leader_id:
                pygame.draw.rect(window, WHITE, (peasant.x - 5, peasant.y + 5, 10, 10))
            else:
                rotated_image, new_rect = pygame_rot_center(pygame_image_fish, (peasant.phi + 270) % 360, peasant.x - 5, peasant.y + 5)
                window.blit(rotated_image, new_rect)
        pygame.display.flip()
    
    plt.plot(game.plot_x, game.plot_y, color='blue')
    plt.grid(True)
    plt.savefig('foo.png')
    
    pygame.quit()

main()
"><meta name=author content><link rel=canonical href=https://mikezom.github.io/posts/2025-07-01-emergence-group-behavior/><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js></script><script>MathJax={tex:{displayMath:[["\\[","\\]"],["$$","$$"]],inlineMath:[["\\(","\\)"]]},loader:{load:["ui/safe"]}}</script><link crossorigin=anonymous href=/assets/css/stylesheet.8fe10233a706bc87f2e08b3cf97b8bd4c0a80f10675a143675d59212121037c0.css integrity="sha256-j+ECM6cGvIfy4Is8+XuL1MCoDxBnWhQ2ddWSEhIQN8A=" rel="preload stylesheet" as=style><link rel=icon href=https://mikezom.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://mikezom.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://mikezom.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://mikezom.github.io/apple-touch-icon.png><link rel=mask-icon href=https://mikezom.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://mikezom.github.io/posts/2025-07-01-emergence-group-behavior/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:url" content="https://mikezom.github.io/posts/2025-07-01-emergence-group-behavior/"><meta property="og:site_name" content="Wandering in Dreams"><meta property="og:title" content="2025 07 02 鸟群行为模拟"><meta property="og:description" content="涌现式群体行为模拟 link: 【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！
鱼群、人群、蜂群等的自然模拟，使用Boids算法。
算法逻辑 $$ \vec{V} = \Pi c_i \vec{v_i} $$其中，\(\vec{V}\)为最终向量，\(c_i\)为可调权重，\(\vec{v_i}\)为单规则向量。
我们有以下3条规则：
规则一：Cohesion, 向群体中心靠拢 目标：保持群体集聚。
行为：计算特定范围（通常为视野范围）内同伴的平均位置，然后产生一个朝向这个平均位置的驱动力。
规则二：Separation, 避免与同伴碰撞 目标：避免碰撞。
行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。
规则三：Alignment, 与同伴移动方向保持一致。 目标：与群体行动方向趋同。
行为：计算特定范围（通常为视野范围）内同伴的平均方向，然后调整方向来匹配平均方向。
算法实现 import numpy as np import random import matplotlib.pyplot as plt import math import statistics import pygame MAX_SPEED = 10.0 WEIGHT_COHESION = 1 WEIGHT_SEPARATION = 1 WEIGHT_ALIGNMENT = 1 WEIGHT_FORCE_AGAINST_WALL = 0 SOCIAL_DISTANCE = 20.0 FRAMERATE = 30 GRAY = (127, 127, 127) WHITE = (255, 255, 255) def cart2pol(x, y): rho = np.sqrt(x**2 + y**2) phi = math.degrees(np.arctan2(y, x)) return((phi + 360) % 360, rho) def pol2cart(phi, rho): x = rho * np.cos(math.radians(phi)) y = rho * np.sin(math.radians(phi)) return(x, y) class EmergenceBehaviorDemo: class Unit: x = 0.0 y = 0.0 phi: float v = 0.0 i: int def __init__(self, i): self.i = i class Playground: w = 1280.0 h = 720.0 def __init__(self): pass unit_index: int peasants: list[Unit] playground: Playground leader_id: int leader_walk_weight_of_previous_tick: float = 0.6 plot_x: list[float] plot_y: list[float] def init_peasants(self, group_grid_width: int, playground: Playground, interval: float) -> list[Unit]: # Generate at the center of the playground class Center: x = playground.w/2 y = playground.h/2 class StartingCoord: x = Center.x - ((group_grid_width - 1) * interval / 2) y = Center.y - ((group_grid_width - 1) * interval / 2) self.unit_index = 0 peasants = [] for i in range(group_grid_width): for j in range(group_grid_width): new_unit = self.Unit(self.unit_index) new_unit.x = StartingCoord.x + (interval * i) new_unit.y = StartingCoord.y + (interval * j) new_unit.phi = random.random() * 360 peasants.append(new_unit) self.unit_index += 1 return peasants @classmethod def print_peasants_coordinates(cls, l:list[Unit]): for unit in l: print(f&#34;Peasant {unit.i}: ({unit.x}, {unit.y}), v = {unit.v}&#34;) return @classmethod def print_peasant_coordinates(cls, u:Unit): print(f&#34;Peasant {u.i}: ({u.x}, {u.y}), phi = {u.phi}° v = {u.v}&#34;) return @classmethod def update_position(cls, u: Unit, p: Playground): u.x += u.v * math.cos(math.radians(u.phi)) u.y += u.v * math.sin(math.radians(u.phi)) u.x = u.x % p.w u.y = u.y % p.h @classmethod def point_in_triangle(cls, p, t_1, t_2, t_3): # https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle def sign(p_1, p_2, p_3): return (p_1[0] - p_3[0]) * (p_2[1] - p_3[1]) - (p_2[0] - p_3[0]) * (p_1[1] - p_3[1]) d1 = sign(p, t_1, t_2) d2 = sign(p, t_2, t_3) d3 = sign(p, t_3, t_1) has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0) has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0) return not (has_neg and has_pos) @classmethod def get_distance(cls, p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def get_all_unit_in_eye_sight(self, u: Unit, fov: float = 90.0, social_distance: float = 20.0, view_distance: float = 300.0) -> list[Unit]: res = [] vertex_1 = (u.x, u.y) vertex_2 = (u.x + math.cos(math.radians(u.phi+(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi+(fov / 2))) * view_distance) vertex_3 = (u.x + math.cos(math.radians(u.phi-(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi-(fov / 2))) * view_distance) # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.point_in_triangle((peasant.x, peasant.y), vertex_1, vertex_2, vertex_3) or self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance: res.append(peasant) return res def get_all_unit_nearby(self, u: Unit, fov: float = 90.0, social_distance: float = 50.0, view_distance: float = 300.0) -> list[Unit]: res = [] # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance: res.append(peasant) return res @classmethod def combine_force_list(cls, l_force: list, l_weight: list = []): final_force_cart = [0, 0] if len(l_weight) == 0: actual_weight = [1] * len(l_force) else: actual_weight = l_weight for i in range(len(l_force)): (x, y) = pol2cart(l_force[i][0], l_force[i][1]) final_force_cart[0] += x * actual_weight[i] final_force_cart[1] += y * actual_weight[i] final_force_rad = cart2pol(final_force_cart[0], final_force_cart[1]) return final_force_rad @classmethod def distance_between_point_and_line(cls, _lv1, _lv2, _p): lv1 = np.array(_lv1) lv2 = np.array(_lv2) p = np.array(_p) return np.abs(np.cross(lv2-lv1, lv1-p)) / np.linalg.norm(lv2-lv1) @classmethod def force_against_the_walls(cls, u: Unit, p: Playground): v1 = (0.0, 0.0) v2 = (0.0, p.h) v3 = (p.w, 0.0) v4 = (p.w, p.h) s = (u.x, u.y) c = 200.0 # Wall 1 v1-v2 d1 = cls.distance_between_point_and_line(v1, v2, s) f1 = (90.0, c / d1) # Wall 2 v1-v3 d2 = cls.distance_between_point_and_line(v1, v3, s) f2 = (180.0, c / d2) # Wall 3 v4-v2 d3 = cls.distance_between_point_and_line(v4, v2, s) f3 = (0.0, c / d3) # Wall 4 v4-v3 d4 = cls.distance_between_point_and_line(v4, v3, s) f4 = (270.0, c / d4) force_against_the_walls_list = [f1, f2, f3, f4] force_against_the_walls = cls.combine_force_list(force_against_the_walls_list) return force_against_the_walls def find_peasant_with_id(self, i): for u in self.peasants: if u.i == i: return u raise Exception('no such id') def update_behavior( self, cohesion_weight: float = WEIGHT_COHESION, separation_weight: float = WEIGHT_SEPARATION, social_distance: float = SOCIAL_DISTANCE, alignment_weight: float = WEIGHT_ALIGNMENT, force_against_wall_weight: float = WEIGHT_FORCE_AGAINST_WALL ): new_direction_list = [] for peasant in self.peasants: peasants_in_view = self.get_all_unit_in_eye_sight(peasant) peasants_nearby = self.get_all_unit_nearby(peasant) # Calculate cohesion if len(peasants_nearby) == 0: cohesion_force = (0, 0) else: average_position_in_view = ( statistics.mean(map(lambda x: x.x, peasants_nearby)), statistics.mean(map(lambda x: x.y, peasants_nearby)) ) (xs, ys) = pol2cart(peasant.phi, peasant.v) cohesion_force = cart2pol((average_position_in_view[0]-xs), (average_position_in_view[1]-ys)) # Calculate Separation separation_force_list = [] for u in self.peasants: if u.i == peasant.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance: c = -1 / math.sqrt((u.y - peasant.y)**2 + (u.x - peasant.x)**2) (x, y) = ((u.x - peasant.x) * c, (u.y - peasant.y) * c) new_force = cart2pol(x, y) separation_force_list.append(new_force) if len(separation_force_list) == 0: separation_force = (0, 0) else: separation_force = self.combine_force_list(separation_force_list) # Calculate Alignment if len(peasants_in_view) == 0: alignment_force = (0, 0) else: average_movement_in_view = ( statistics.mean(map(lambda x: x.phi, peasants_in_view)), statistics.mean(map(lambda x: x.v, peasants_in_view)) ) (xt, yt) = pol2cart(average_movement_in_view[0], average_movement_in_view[1]) (xs, ys) = pol2cart(peasant.phi, peasant.v) alignment_force = cart2pol((xt-xs), (yt-ys)) # Calculate force against the wall force_against_wall = self.force_against_the_walls(peasant, self.playground) cohesion_force = (cohesion_force[0], cohesion_force[1]**0.75) alignment_force = (alignment_force[0], math.sqrt(alignment_force[1])) total_force = self.combine_force_list( [cohesion_force, separation_force, alignment_force, force_against_wall], [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight] ) if peasant.i == self.leader_id: print(f&#34;c_force:({cohesion_force[0]:.2f}°, {cohesion_force[1]:.2f}m/s) s_force:({separation_force[0]:.2f}°, {separation_force[1]:.2f}m/s) a_force:({alignment_force[0]:.2f}°, {alignment_force[1]:.2f}m/s) f_force:({force_against_wall[0]:.2f}°, {force_against_wall[1]:.2f}m/s)&#34;) new_direction_list.append((peasant.i, total_force)) for (_i, (_phi, _v)) in new_direction_list: current_peasant = self.peasants[_i] current_peasant.phi = _phi current_peasant.v = min(_v, MAX_SPEED) for peasant in self.peasants: self.update_position(peasant, self.playground) def __init__(self, group_grid_width: int, interval: float): self.playground = self.Playground() self.peasants = self.init_peasants(group_grid_width, self.playground, interval) self.leader_id = random.randint(0, len(self.peasants)-1) self.plot_x = [] self.plot_y = [] pass def pygame_rot_center(image, angle, x, y): rotated_image = pygame.transform.rotate(image, angle) new_rect = rotated_image.get_rect(center = image.get_rect(center = (x, y)).center) return rotated_image, new_rect def main(): run = True game = EmergenceBehaviorDemo(7, 10.0) pygame.init() window = pygame.display.set_mode((game.playground.w, game.playground.h)) clock = pygame.time.Clock() pygame_image_fish = pygame.image.load('fish.png').convert_alpha() while run: clock.tick(FRAMERATE) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False game.update_behavior() window.fill(GRAY) for peasant in game.peasants: if peasant.i == game.leader_id: pygame.draw.rect(window, WHITE, (peasant.x - 5, peasant.y + 5, 10, 10)) else: rotated_image, new_rect = pygame_rot_center(pygame_image_fish, (peasant.phi + 270) % 360, peasant.x - 5, peasant.y + 5) window.blit(rotated_image, new_rect) pygame.display.flip() plt.plot(game.plot_x, game.plot_y, color='blue') plt.grid(True) plt.savefig('foo.png') pygame.quit() main() "><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-07-01T00:23:34+08:00"><meta property="article:modified_time" content="2025-07-01T00:23:34+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="2025 07 02 鸟群行为模拟"><meta name=twitter:description content="涌现式群体行为模拟
link: 【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！
鱼群、人群、蜂群等的自然模拟，使用Boids算法。
算法逻辑
$$
\vec{V} = \Pi c_i \vec{v_i} 
$$其中，\(\vec{V}\)为最终向量，\(c_i\)为可调权重，\(\vec{v_i}\)为单规则向量。
我们有以下3条规则：
规则一：Cohesion, 向群体中心靠拢
目标：保持群体集聚。
行为：计算特定范围（通常为视野范围）内同伴的平均位置，然后产生一个朝向这个平均位置的驱动力。
规则二：Separation, 避免与同伴碰撞
目标：避免碰撞。
行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。
规则三：Alignment, 与同伴移动方向保持一致。
目标：与群体行动方向趋同。
行为：计算特定范围（通常为视野范围）内同伴的平均方向，然后调整方向来匹配平均方向。
算法实现

import numpy as np
import random
import matplotlib.pyplot as plt
import math
import statistics
import pygame

MAX_SPEED = 10.0
WEIGHT_COHESION = 1
WEIGHT_SEPARATION = 1
WEIGHT_ALIGNMENT = 1
WEIGHT_FORCE_AGAINST_WALL = 0
SOCIAL_DISTANCE = 20.0
FRAMERATE = 30

GRAY = (127, 127, 127)
WHITE = (255, 255, 255)

def cart2pol(x, y):
    rho = np.sqrt(x**2 + y**2)
    phi = math.degrees(np.arctan2(y, x))
    return((phi + 360) % 360, rho)

def pol2cart(phi, rho):
    x = rho * np.cos(math.radians(phi))
    y = rho * np.sin(math.radians(phi))
    return(x, y)

class EmergenceBehaviorDemo:
    class Unit:
        x = 0.0
        y = 0.0
        phi: float
        v = 0.0
        i: int
        def __init__(self, i):
            self.i = i
    
    class Playground:
        w = 1280.0
        h = 720.0
        def __init__(self):
            pass
    
    unit_index: int
    peasants: list[Unit]
    playground: Playground
    leader_id: int
    leader_walk_weight_of_previous_tick: float = 0.6
    plot_x: list[float]
    plot_y: list[float]
    
    def init_peasants(self, group_grid_width: int, playground: Playground, interval: float) -> list[Unit]:
        # Generate at the center of the playground
        
        class Center:
            x = playground.w/2
            y = playground.h/2
        
        class StartingCoord:
            x = Center.x - ((group_grid_width - 1) * interval / 2)
            y = Center.y - ((group_grid_width - 1) * interval / 2)
        
        self.unit_index = 0
        peasants = []
        for i in range(group_grid_width):
            for j in range(group_grid_width):
                new_unit = self.Unit(self.unit_index)
                new_unit.x = StartingCoord.x + (interval * i)
                new_unit.y = StartingCoord.y + (interval * j)
                new_unit.phi = random.random() * 360
                peasants.append(new_unit)
                self.unit_index += 1
        
        return peasants
    
    @classmethod            
    def print_peasants_coordinates(cls, l:list[Unit]):
        for unit in l:
            print(f&#34;Peasant {unit.i}: ({unit.x}, {unit.y}), v = {unit.v}&#34;)
        return
    
    @classmethod  
    def print_peasant_coordinates(cls, u:Unit):
        print(f&#34;Peasant {u.i}: ({u.x}, {u.y}), phi = {u.phi}° v = {u.v}&#34;)
        return
    
    @classmethod  
    def update_position(cls, u: Unit, p: Playground):
        u.x += u.v * math.cos(math.radians(u.phi)) 
        u.y += u.v * math.sin(math.radians(u.phi))
        u.x = u.x % p.w
        u.y = u.y % p.h
    
    @classmethod  
    def point_in_triangle(cls, p, t_1, t_2, t_3):
        # https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle
        def sign(p_1, p_2, p_3):
            return (p_1[0] - p_3[0]) * (p_2[1] - p_3[1]) - (p_2[0] - p_3[0]) * (p_1[1] - p_3[1])

        d1 = sign(p, t_1, t_2)
        d2 = sign(p, t_2, t_3)
        d3 = sign(p, t_3, t_1)
        
        has_neg = (d1 < 0) or (d2 < 0) or (d3 < 0)
        has_pos = (d1 > 0) or (d2 > 0) or (d3 > 0)
    
        return not (has_neg and has_pos)
    
    @classmethod  
    def get_distance(cls, p1, p2):
        return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)
    
    def get_all_unit_in_eye_sight(self, u: Unit, fov: float = 90.0, social_distance: float = 20.0, view_distance: float = 300.0) -> list[Unit]:
        res = []
        vertex_1 = (u.x, u.y)
        vertex_2 = (u.x + math.cos(math.radians(u.phi+(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi+(fov / 2))) * view_distance)
        vertex_3 = (u.x + math.cos(math.radians(u.phi-(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi-(fov / 2))) * view_distance)
        
        # Now we have one triangle
        for peasant in self.peasants:
            if peasant.i == u.i:
                continue
            if self.point_in_triangle((peasant.x, peasant.y), vertex_1, vertex_2, vertex_3) or self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                res.append(peasant)
        
        return res
    
    def get_all_unit_nearby(self, u: Unit, fov: float = 90.0, social_distance: float = 50.0, view_distance: float = 300.0) -> list[Unit]:
        res = []
        
        # Now we have one triangle
        for peasant in self.peasants:
            if peasant.i == u.i:
                continue
            if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                res.append(peasant)
        
        return res
    
    @classmethod  
    def combine_force_list(cls, l_force: list, l_weight: list = []):
        final_force_cart = [0, 0]
        
        if len(l_weight) == 0:
            actual_weight = [1] * len(l_force)
        else:
            actual_weight = l_weight
        
        for i in range(len(l_force)):
            (x, y) = pol2cart(l_force[i][0], l_force[i][1])
            final_force_cart[0] += x * actual_weight[i]
            final_force_cart[1] += y * actual_weight[i]
        
        final_force_rad = cart2pol(final_force_cart[0], final_force_cart[1])
        
        return final_force_rad
    
    @classmethod  
    def distance_between_point_and_line(cls, _lv1, _lv2, _p):
        lv1 = np.array(_lv1)
        lv2 = np.array(_lv2)
        p = np.array(_p)
        return np.abs(np.cross(lv2-lv1, lv1-p)) / np.linalg.norm(lv2-lv1)
    
    @classmethod  
    def force_against_the_walls(cls, u: Unit, p: Playground):
        v1 = (0.0, 0.0)
        v2 = (0.0, p.h)
        v3 = (p.w, 0.0)
        v4 = (p.w, p.h)
        s = (u.x, u.y)
        c = 200.0
        
        # Wall 1 v1-v2
        d1 = cls.distance_between_point_and_line(v1, v2, s)
        f1 = (90.0, c / d1)
        # Wall 2 v1-v3
        d2 = cls.distance_between_point_and_line(v1, v3, s)
        f2 = (180.0, c / d2)
        # Wall 3 v4-v2
        d3 = cls.distance_between_point_and_line(v4, v2, s)
        f3 = (0.0, c / d3)
        # Wall 4 v4-v3
        d4 = cls.distance_between_point_and_line(v4, v3, s)
        f4 = (270.0, c / d4)
        
        force_against_the_walls_list = [f1, f2, f3, f4]
        force_against_the_walls = cls.combine_force_list(force_against_the_walls_list)
        
        return force_against_the_walls
    
    def find_peasant_with_id(self, i):
        for u in self.peasants:
            if u.i == i: return u
        raise Exception('no such id')
    
    def update_behavior(
        self, 
        cohesion_weight: float = WEIGHT_COHESION, 
        separation_weight: float = WEIGHT_SEPARATION,
        social_distance: float = SOCIAL_DISTANCE, 
        alignment_weight: float = WEIGHT_ALIGNMENT,
        force_against_wall_weight: float = WEIGHT_FORCE_AGAINST_WALL
    ):
        
        new_direction_list = []
        for peasant in self.peasants:
            
            peasants_in_view = self.get_all_unit_in_eye_sight(peasant)
            peasants_nearby = self.get_all_unit_nearby(peasant)
            
            # Calculate cohesion
            if len(peasants_nearby) == 0:
                cohesion_force = (0, 0)
            else:
                
                average_position_in_view = (
                    statistics.mean(map(lambda x: x.x, peasants_nearby)),
                    statistics.mean(map(lambda x: x.y, peasants_nearby))
                )
                (xs, ys) = pol2cart(peasant.phi, peasant.v)
                cohesion_force = cart2pol((average_position_in_view[0]-xs), (average_position_in_view[1]-ys))
                
            # Calculate Separation
            separation_force_list = []
            for u in self.peasants:
                if u.i == peasant.i:
                    continue
                if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) <= social_distance:
                    c = -1 / math.sqrt((u.y - peasant.y)**2 + (u.x - peasant.x)**2)
                    (x, y) = ((u.x - peasant.x) * c, (u.y - peasant.y) * c)
                    new_force = cart2pol(x, y)
                    separation_force_list.append(new_force)
            
            if len(separation_force_list) == 0:
                separation_force = (0, 0)
            else:
                separation_force = self.combine_force_list(separation_force_list)
            
            # Calculate Alignment
            if len(peasants_in_view) == 0:
                alignment_force = (0, 0)
            else:
                average_movement_in_view = (
                    statistics.mean(map(lambda x: x.phi, peasants_in_view)),
                    statistics.mean(map(lambda x: x.v, peasants_in_view))
                )
                
                (xt, yt) = pol2cart(average_movement_in_view[0], average_movement_in_view[1])
                (xs, ys) = pol2cart(peasant.phi, peasant.v)
                
                alignment_force = cart2pol((xt-xs), (yt-ys))
            
            # Calculate force against the wall
            force_against_wall = self.force_against_the_walls(peasant, self.playground)
            
            cohesion_force = (cohesion_force[0], cohesion_force[1]**0.75)
            alignment_force = (alignment_force[0], math.sqrt(alignment_force[1]))
            
            total_force = self.combine_force_list(
                [cohesion_force, separation_force, alignment_force, force_against_wall],
                [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight]
            )
            
            if peasant.i == self.leader_id:
                print(f&#34;c_force:({cohesion_force[0]:.2f}°, {cohesion_force[1]:.2f}m/s) s_force:({separation_force[0]:.2f}°, {separation_force[1]:.2f}m/s) a_force:({alignment_force[0]:.2f}°, {alignment_force[1]:.2f}m/s) f_force:({force_against_wall[0]:.2f}°, {force_against_wall[1]:.2f}m/s)&#34;)
            
            new_direction_list.append((peasant.i, total_force))
            
        for (_i, (_phi, _v)) in new_direction_list:
            current_peasant = self.peasants[_i]
            current_peasant.phi = _phi
            current_peasant.v = min(_v, MAX_SPEED)
        
        for peasant in self.peasants:
            self.update_position(peasant, self.playground)
    
    def __init__(self, group_grid_width: int, interval: float):
        self.playground = self.Playground()
        self.peasants = self.init_peasants(group_grid_width, self.playground, interval)
        self.leader_id = random.randint(0, len(self.peasants)-1)
        self.plot_x = []
        self.plot_y = []
        pass

def pygame_rot_center(image, angle, x, y):
    
    rotated_image = pygame.transform.rotate(image, angle)
    new_rect = rotated_image.get_rect(center = image.get_rect(center = (x, y)).center)

    return rotated_image, new_rect

def main():
    run = True
    
    game = EmergenceBehaviorDemo(7, 10.0)
    
    pygame.init()
    window = pygame.display.set_mode((game.playground.w, game.playground.h))
    clock = pygame.time.Clock()
    
    pygame_image_fish = pygame.image.load('fish.png').convert_alpha()
    
    
    while run:
        clock.tick(FRAMERATE)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                run = False
        
        game.update_behavior()

        window.fill(GRAY)
        for peasant in game.peasants:
            if peasant.i == game.leader_id:
                pygame.draw.rect(window, WHITE, (peasant.x - 5, peasant.y + 5, 10, 10))
            else:
                rotated_image, new_rect = pygame_rot_center(pygame_image_fish, (peasant.phi + 270) % 360, peasant.x - 5, peasant.y + 5)
                window.blit(rotated_image, new_rect)
        pygame.display.flip()
    
    plt.plot(game.plot_x, game.plot_y, color='blue')
    plt.grid(True)
    plt.savefig('foo.png')
    
    pygame.quit()

main()
"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://mikezom.github.io/posts/"},{"@type":"ListItem","position":2,"name":"2025 07 02 鸟群行为模拟","item":"https://mikezom.github.io/posts/2025-07-01-emergence-group-behavior/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"2025 07 02 鸟群行为模拟","name":"2025 07 02 鸟群行为模拟","description":"涌现式群体行为模拟 link: 【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！\n鱼群、人群、蜂群等的自然模拟，使用Boids算法。\n算法逻辑 $$ \\vec{V} = \\Pi c_i \\vec{v_i} $$其中，\\(\\vec{V}\\)为最终向量，\\(c_i\\)为可调权重，\\(\\vec{v_i}\\)为单规则向量。\n我们有以下3条规则：\n规则一：Cohesion, 向群体中心靠拢 目标：保持群体集聚。\n行为：计算特定范围（通常为视野范围）内同伴的平均位置，然后产生一个朝向这个平均位置的驱动力。\n规则二：Separation, 避免与同伴碰撞 目标：避免碰撞。\n行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。\n规则三：Alignment, 与同伴移动方向保持一致。 目标：与群体行动方向趋同。\n行为：计算特定范围（通常为视野范围）内同伴的平均方向，然后调整方向来匹配平均方向。\n算法实现 import numpy as np import random import matplotlib.pyplot as plt import math import statistics import pygame MAX_SPEED = 10.0 WEIGHT_COHESION = 1 WEIGHT_SEPARATION = 1 WEIGHT_ALIGNMENT = 1 WEIGHT_FORCE_AGAINST_WALL = 0 SOCIAL_DISTANCE = 20.0 FRAMERATE = 30 GRAY = (127, 127, 127) WHITE = (255, 255, 255) def cart2pol(x, y): rho = np.sqrt(x**2 + y**2) phi = math.degrees(np.arctan2(y, x)) return((phi + 360) % 360, rho) def pol2cart(phi, rho): x = rho * np.cos(math.radians(phi)) y = rho * np.sin(math.radians(phi)) return(x, y) class EmergenceBehaviorDemo: class Unit: x = 0.0 y = 0.0 phi: float v = 0.0 i: int def __init__(self, i): self.i = i class Playground: w = 1280.0 h = 720.0 def __init__(self): pass unit_index: int peasants: list[Unit] playground: Playground leader_id: int leader_walk_weight_of_previous_tick: float = 0.6 plot_x: list[float] plot_y: list[float] def init_peasants(self, group_grid_width: int, playground: Playground, interval: float) -\u0026gt; list[Unit]: # Generate at the center of the playground class Center: x = playground.w/2 y = playground.h/2 class StartingCoord: x = Center.x - ((group_grid_width - 1) * interval / 2) y = Center.y - ((group_grid_width - 1) * interval / 2) self.unit_index = 0 peasants = [] for i in range(group_grid_width): for j in range(group_grid_width): new_unit = self.Unit(self.unit_index) new_unit.x = StartingCoord.x + (interval * i) new_unit.y = StartingCoord.y + (interval * j) new_unit.phi = random.random() * 360 peasants.append(new_unit) self.unit_index += 1 return peasants @classmethod def print_peasants_coordinates(cls, l:list[Unit]): for unit in l: print(f\u0026#34;Peasant {unit.i}: ({unit.x}, {unit.y}), v = {unit.v}\u0026#34;) return @classmethod def print_peasant_coordinates(cls, u:Unit): print(f\u0026#34;Peasant {u.i}: ({u.x}, {u.y}), phi = {u.phi}° v = {u.v}\u0026#34;) return @classmethod def update_position(cls, u: Unit, p: Playground): u.x += u.v * math.cos(math.radians(u.phi)) u.y += u.v * math.sin(math.radians(u.phi)) u.x = u.x % p.w u.y = u.y % p.h @classmethod def point_in_triangle(cls, p, t_1, t_2, t_3): # https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle def sign(p_1, p_2, p_3): return (p_1[0] - p_3[0]) * (p_2[1] - p_3[1]) - (p_2[0] - p_3[0]) * (p_1[1] - p_3[1]) d1 = sign(p, t_1, t_2) d2 = sign(p, t_2, t_3) d3 = sign(p, t_3, t_1) has_neg = (d1 \u0026lt; 0) or (d2 \u0026lt; 0) or (d3 \u0026lt; 0) has_pos = (d1 \u0026gt; 0) or (d2 \u0026gt; 0) or (d3 \u0026gt; 0) return not (has_neg and has_pos) @classmethod def get_distance(cls, p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def get_all_unit_in_eye_sight(self, u: Unit, fov: float = 90.0, social_distance: float = 20.0, view_distance: float = 300.0) -\u0026gt; list[Unit]: res = [] vertex_1 = (u.x, u.y) vertex_2 = (u.x + math.cos(math.radians(u.phi+(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi+(fov / 2))) * view_distance) vertex_3 = (u.x + math.cos(math.radians(u.phi-(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi-(fov / 2))) * view_distance) # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.point_in_triangle((peasant.x, peasant.y), vertex_1, vertex_2, vertex_3) or self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u0026lt;= social_distance: res.append(peasant) return res def get_all_unit_nearby(self, u: Unit, fov: float = 90.0, social_distance: float = 50.0, view_distance: float = 300.0) -\u0026gt; list[Unit]: res = [] # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u0026lt;= social_distance: res.append(peasant) return res @classmethod def combine_force_list(cls, l_force: list, l_weight: list = []): final_force_cart = [0, 0] if len(l_weight) == 0: actual_weight = [1] * len(l_force) else: actual_weight = l_weight for i in range(len(l_force)): (x, y) = pol2cart(l_force[i][0], l_force[i][1]) final_force_cart[0] += x * actual_weight[i] final_force_cart[1] += y * actual_weight[i] final_force_rad = cart2pol(final_force_cart[0], final_force_cart[1]) return final_force_rad @classmethod def distance_between_point_and_line(cls, _lv1, _lv2, _p): lv1 = np.array(_lv1) lv2 = np.array(_lv2) p = np.array(_p) return np.abs(np.cross(lv2-lv1, lv1-p)) / np.linalg.norm(lv2-lv1) @classmethod def force_against_the_walls(cls, u: Unit, p: Playground): v1 = (0.0, 0.0) v2 = (0.0, p.h) v3 = (p.w, 0.0) v4 = (p.w, p.h) s = (u.x, u.y) c = 200.0 # Wall 1 v1-v2 d1 = cls.distance_between_point_and_line(v1, v2, s) f1 = (90.0, c / d1) # Wall 2 v1-v3 d2 = cls.distance_between_point_and_line(v1, v3, s) f2 = (180.0, c / d2) # Wall 3 v4-v2 d3 = cls.distance_between_point_and_line(v4, v2, s) f3 = (0.0, c / d3) # Wall 4 v4-v3 d4 = cls.distance_between_point_and_line(v4, v3, s) f4 = (270.0, c / d4) force_against_the_walls_list = [f1, f2, f3, f4] force_against_the_walls = cls.combine_force_list(force_against_the_walls_list) return force_against_the_walls def find_peasant_with_id(self, i): for u in self.peasants: if u.i == i: return u raise Exception(\u0026#39;no such id\u0026#39;) def update_behavior( self, cohesion_weight: float = WEIGHT_COHESION, separation_weight: float = WEIGHT_SEPARATION, social_distance: float = SOCIAL_DISTANCE, alignment_weight: float = WEIGHT_ALIGNMENT, force_against_wall_weight: float = WEIGHT_FORCE_AGAINST_WALL ): new_direction_list = [] for peasant in self.peasants: peasants_in_view = self.get_all_unit_in_eye_sight(peasant) peasants_nearby = self.get_all_unit_nearby(peasant) # Calculate cohesion if len(peasants_nearby) == 0: cohesion_force = (0, 0) else: average_position_in_view = ( statistics.mean(map(lambda x: x.x, peasants_nearby)), statistics.mean(map(lambda x: x.y, peasants_nearby)) ) (xs, ys) = pol2cart(peasant.phi, peasant.v) cohesion_force = cart2pol((average_position_in_view[0]-xs), (average_position_in_view[1]-ys)) # Calculate Separation separation_force_list = [] for u in self.peasants: if u.i == peasant.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u0026lt;= social_distance: c = -1 / math.sqrt((u.y - peasant.y)**2 + (u.x - peasant.x)**2) (x, y) = ((u.x - peasant.x) * c, (u.y - peasant.y) * c) new_force = cart2pol(x, y) separation_force_list.append(new_force) if len(separation_force_list) == 0: separation_force = (0, 0) else: separation_force = self.combine_force_list(separation_force_list) # Calculate Alignment if len(peasants_in_view) == 0: alignment_force = (0, 0) else: average_movement_in_view = ( statistics.mean(map(lambda x: x.phi, peasants_in_view)), statistics.mean(map(lambda x: x.v, peasants_in_view)) ) (xt, yt) = pol2cart(average_movement_in_view[0], average_movement_in_view[1]) (xs, ys) = pol2cart(peasant.phi, peasant.v) alignment_force = cart2pol((xt-xs), (yt-ys)) # Calculate force against the wall force_against_wall = self.force_against_the_walls(peasant, self.playground) cohesion_force = (cohesion_force[0], cohesion_force[1]**0.75) alignment_force = (alignment_force[0], math.sqrt(alignment_force[1])) total_force = self.combine_force_list( [cohesion_force, separation_force, alignment_force, force_against_wall], [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight] ) if peasant.i == self.leader_id: print(f\u0026#34;c_force:({cohesion_force[0]:.2f}°, {cohesion_force[1]:.2f}m/s) s_force:({separation_force[0]:.2f}°, {separation_force[1]:.2f}m/s) a_force:({alignment_force[0]:.2f}°, {alignment_force[1]:.2f}m/s) f_force:({force_against_wall[0]:.2f}°, {force_against_wall[1]:.2f}m/s)\u0026#34;) new_direction_list.append((peasant.i, total_force)) for (_i, (_phi, _v)) in new_direction_list: current_peasant = self.peasants[_i] current_peasant.phi = _phi current_peasant.v = min(_v, MAX_SPEED) for peasant in self.peasants: self.update_position(peasant, self.playground) def __init__(self, group_grid_width: int, interval: float): self.playground = self.Playground() self.peasants = self.init_peasants(group_grid_width, self.playground, interval) self.leader_id = random.randint(0, len(self.peasants)-1) self.plot_x = [] self.plot_y = [] pass def pygame_rot_center(image, angle, x, y): rotated_image = pygame.transform.rotate(image, angle) new_rect = rotated_image.get_rect(center = image.get_rect(center = (x, y)).center) return rotated_image, new_rect def main(): run = True game = EmergenceBehaviorDemo(7, 10.0) pygame.init() window = pygame.display.set_mode((game.playground.w, game.playground.h)) clock = pygame.time.Clock() pygame_image_fish = pygame.image.load(\u0026#39;fish.png\u0026#39;).convert_alpha() while run: clock.tick(FRAMERATE) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False game.update_behavior() window.fill(GRAY) for peasant in game.peasants: if peasant.i == game.leader_id: pygame.draw.rect(window, WHITE, (peasant.x - 5, peasant.y + 5, 10, 10)) else: rotated_image, new_rect = pygame_rot_center(pygame_image_fish, (peasant.phi + 270) % 360, peasant.x - 5, peasant.y + 5) window.blit(rotated_image, new_rect) pygame.display.flip() plt.plot(game.plot_x, game.plot_y, color=\u0026#39;blue\u0026#39;) plt.grid(True) plt.savefig(\u0026#39;foo.png\u0026#39;) pygame.quit() main() ","keywords":[],"articleBody":"涌现式群体行为模拟 link: 【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！\n鱼群、人群、蜂群等的自然模拟，使用Boids算法。\n算法逻辑 $$ \\vec{V} = \\Pi c_i \\vec{v_i} $$其中，\\(\\vec{V}\\)为最终向量，\\(c_i\\)为可调权重，\\(\\vec{v_i}\\)为单规则向量。\n我们有以下3条规则：\n规则一：Cohesion, 向群体中心靠拢 目标：保持群体集聚。\n行为：计算特定范围（通常为视野范围）内同伴的平均位置，然后产生一个朝向这个平均位置的驱动力。\n规则二：Separation, 避免与同伴碰撞 目标：避免碰撞。\n行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。\n规则三：Alignment, 与同伴移动方向保持一致。 目标：与群体行动方向趋同。\n行为：计算特定范围（通常为视野范围）内同伴的平均方向，然后调整方向来匹配平均方向。\n算法实现 import numpy as np import random import matplotlib.pyplot as plt import math import statistics import pygame MAX_SPEED = 10.0 WEIGHT_COHESION = 1 WEIGHT_SEPARATION = 1 WEIGHT_ALIGNMENT = 1 WEIGHT_FORCE_AGAINST_WALL = 0 SOCIAL_DISTANCE = 20.0 FRAMERATE = 30 GRAY = (127, 127, 127) WHITE = (255, 255, 255) def cart2pol(x, y): rho = np.sqrt(x**2 + y**2) phi = math.degrees(np.arctan2(y, x)) return((phi + 360) % 360, rho) def pol2cart(phi, rho): x = rho * np.cos(math.radians(phi)) y = rho * np.sin(math.radians(phi)) return(x, y) class EmergenceBehaviorDemo: class Unit: x = 0.0 y = 0.0 phi: float v = 0.0 i: int def __init__(self, i): self.i = i class Playground: w = 1280.0 h = 720.0 def __init__(self): pass unit_index: int peasants: list[Unit] playground: Playground leader_id: int leader_walk_weight_of_previous_tick: float = 0.6 plot_x: list[float] plot_y: list[float] def init_peasants(self, group_grid_width: int, playground: Playground, interval: float) -\u003e list[Unit]: # Generate at the center of the playground class Center: x = playground.w/2 y = playground.h/2 class StartingCoord: x = Center.x - ((group_grid_width - 1) * interval / 2) y = Center.y - ((group_grid_width - 1) * interval / 2) self.unit_index = 0 peasants = [] for i in range(group_grid_width): for j in range(group_grid_width): new_unit = self.Unit(self.unit_index) new_unit.x = StartingCoord.x + (interval * i) new_unit.y = StartingCoord.y + (interval * j) new_unit.phi = random.random() * 360 peasants.append(new_unit) self.unit_index += 1 return peasants @classmethod def print_peasants_coordinates(cls, l:list[Unit]): for unit in l: print(f\"Peasant {unit.i}: ({unit.x}, {unit.y}), v = {unit.v}\") return @classmethod def print_peasant_coordinates(cls, u:Unit): print(f\"Peasant {u.i}: ({u.x}, {u.y}), phi = {u.phi}° v = {u.v}\") return @classmethod def update_position(cls, u: Unit, p: Playground): u.x += u.v * math.cos(math.radians(u.phi)) u.y += u.v * math.sin(math.radians(u.phi)) u.x = u.x % p.w u.y = u.y % p.h @classmethod def point_in_triangle(cls, p, t_1, t_2, t_3): # https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle def sign(p_1, p_2, p_3): return (p_1[0] - p_3[0]) * (p_2[1] - p_3[1]) - (p_2[0] - p_3[0]) * (p_1[1] - p_3[1]) d1 = sign(p, t_1, t_2) d2 = sign(p, t_2, t_3) d3 = sign(p, t_3, t_1) has_neg = (d1 \u003c 0) or (d2 \u003c 0) or (d3 \u003c 0) has_pos = (d1 \u003e 0) or (d2 \u003e 0) or (d3 \u003e 0) return not (has_neg and has_pos) @classmethod def get_distance(cls, p1, p2): return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2) def get_all_unit_in_eye_sight(self, u: Unit, fov: float = 90.0, social_distance: float = 20.0, view_distance: float = 300.0) -\u003e list[Unit]: res = [] vertex_1 = (u.x, u.y) vertex_2 = (u.x + math.cos(math.radians(u.phi+(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi+(fov / 2))) * view_distance) vertex_3 = (u.x + math.cos(math.radians(u.phi-(fov / 2))) * view_distance, u.y + math.sin(math.radians(u.phi-(fov / 2))) * view_distance) # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.point_in_triangle((peasant.x, peasant.y), vertex_1, vertex_2, vertex_3) or self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u003c= social_distance: res.append(peasant) return res def get_all_unit_nearby(self, u: Unit, fov: float = 90.0, social_distance: float = 50.0, view_distance: float = 300.0) -\u003e list[Unit]: res = [] # Now we have one triangle for peasant in self.peasants: if peasant.i == u.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u003c= social_distance: res.append(peasant) return res @classmethod def combine_force_list(cls, l_force: list, l_weight: list = []): final_force_cart = [0, 0] if len(l_weight) == 0: actual_weight = [1] * len(l_force) else: actual_weight = l_weight for i in range(len(l_force)): (x, y) = pol2cart(l_force[i][0], l_force[i][1]) final_force_cart[0] += x * actual_weight[i] final_force_cart[1] += y * actual_weight[i] final_force_rad = cart2pol(final_force_cart[0], final_force_cart[1]) return final_force_rad @classmethod def distance_between_point_and_line(cls, _lv1, _lv2, _p): lv1 = np.array(_lv1) lv2 = np.array(_lv2) p = np.array(_p) return np.abs(np.cross(lv2-lv1, lv1-p)) / np.linalg.norm(lv2-lv1) @classmethod def force_against_the_walls(cls, u: Unit, p: Playground): v1 = (0.0, 0.0) v2 = (0.0, p.h) v3 = (p.w, 0.0) v4 = (p.w, p.h) s = (u.x, u.y) c = 200.0 # Wall 1 v1-v2 d1 = cls.distance_between_point_and_line(v1, v2, s) f1 = (90.0, c / d1) # Wall 2 v1-v3 d2 = cls.distance_between_point_and_line(v1, v3, s) f2 = (180.0, c / d2) # Wall 3 v4-v2 d3 = cls.distance_between_point_and_line(v4, v2, s) f3 = (0.0, c / d3) # Wall 4 v4-v3 d4 = cls.distance_between_point_and_line(v4, v3, s) f4 = (270.0, c / d4) force_against_the_walls_list = [f1, f2, f3, f4] force_against_the_walls = cls.combine_force_list(force_against_the_walls_list) return force_against_the_walls def find_peasant_with_id(self, i): for u in self.peasants: if u.i == i: return u raise Exception('no such id') def update_behavior( self, cohesion_weight: float = WEIGHT_COHESION, separation_weight: float = WEIGHT_SEPARATION, social_distance: float = SOCIAL_DISTANCE, alignment_weight: float = WEIGHT_ALIGNMENT, force_against_wall_weight: float = WEIGHT_FORCE_AGAINST_WALL ): new_direction_list = [] for peasant in self.peasants: peasants_in_view = self.get_all_unit_in_eye_sight(peasant) peasants_nearby = self.get_all_unit_nearby(peasant) # Calculate cohesion if len(peasants_nearby) == 0: cohesion_force = (0, 0) else: average_position_in_view = ( statistics.mean(map(lambda x: x.x, peasants_nearby)), statistics.mean(map(lambda x: x.y, peasants_nearby)) ) (xs, ys) = pol2cart(peasant.phi, peasant.v) cohesion_force = cart2pol((average_position_in_view[0]-xs), (average_position_in_view[1]-ys)) # Calculate Separation separation_force_list = [] for u in self.peasants: if u.i == peasant.i: continue if self.get_distance((u.x, u.y), (peasant.x, peasant.y)) \u003c= social_distance: c = -1 / math.sqrt((u.y - peasant.y)**2 + (u.x - peasant.x)**2) (x, y) = ((u.x - peasant.x) * c, (u.y - peasant.y) * c) new_force = cart2pol(x, y) separation_force_list.append(new_force) if len(separation_force_list) == 0: separation_force = (0, 0) else: separation_force = self.combine_force_list(separation_force_list) # Calculate Alignment if len(peasants_in_view) == 0: alignment_force = (0, 0) else: average_movement_in_view = ( statistics.mean(map(lambda x: x.phi, peasants_in_view)), statistics.mean(map(lambda x: x.v, peasants_in_view)) ) (xt, yt) = pol2cart(average_movement_in_view[0], average_movement_in_view[1]) (xs, ys) = pol2cart(peasant.phi, peasant.v) alignment_force = cart2pol((xt-xs), (yt-ys)) # Calculate force against the wall force_against_wall = self.force_against_the_walls(peasant, self.playground) cohesion_force = (cohesion_force[0], cohesion_force[1]**0.75) alignment_force = (alignment_force[0], math.sqrt(alignment_force[1])) total_force = self.combine_force_list( [cohesion_force, separation_force, alignment_force, force_against_wall], [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight] ) if peasant.i == self.leader_id: print(f\"c_force:({cohesion_force[0]:.2f}°, {cohesion_force[1]:.2f}m/s) s_force:({separation_force[0]:.2f}°, {separation_force[1]:.2f}m/s) a_force:({alignment_force[0]:.2f}°, {alignment_force[1]:.2f}m/s) f_force:({force_against_wall[0]:.2f}°, {force_against_wall[1]:.2f}m/s)\") new_direction_list.append((peasant.i, total_force)) for (_i, (_phi, _v)) in new_direction_list: current_peasant = self.peasants[_i] current_peasant.phi = _phi current_peasant.v = min(_v, MAX_SPEED) for peasant in self.peasants: self.update_position(peasant, self.playground) def __init__(self, group_grid_width: int, interval: float): self.playground = self.Playground() self.peasants = self.init_peasants(group_grid_width, self.playground, interval) self.leader_id = random.randint(0, len(self.peasants)-1) self.plot_x = [] self.plot_y = [] pass def pygame_rot_center(image, angle, x, y): rotated_image = pygame.transform.rotate(image, angle) new_rect = rotated_image.get_rect(center = image.get_rect(center = (x, y)).center) return rotated_image, new_rect def main(): run = True game = EmergenceBehaviorDemo(7, 10.0) pygame.init() window = pygame.display.set_mode((game.playground.w, game.playground.h)) clock = pygame.time.Clock() pygame_image_fish = pygame.image.load('fish.png').convert_alpha() while run: clock.tick(FRAMERATE) for event in pygame.event.get(): if event.type == pygame.QUIT: run = False game.update_behavior() window.fill(GRAY) for peasant in game.peasants: if peasant.i == game.leader_id: pygame.draw.rect(window, WHITE, (peasant.x - 5, peasant.y + 5, 10, 10)) else: rotated_image, new_rect = pygame_rot_center(pygame_image_fish, (peasant.phi + 270) % 360, peasant.x - 5, peasant.y + 5) window.blit(rotated_image, new_rect) pygame.display.flip() plt.plot(game.plot_x, game.plot_y, color='blue') plt.grid(True) plt.savefig('foo.png') pygame.quit() main() ","wordCount":"1079","inLanguage":"en","datePublished":"2025-07-01T00:23:34+08:00","dateModified":"2025-07-01T00:23:34+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://mikezom.github.io/posts/2025-07-01-emergence-group-behavior/"},"publisher":{"@type":"Organization","name":"Wandering in Dreams","logo":{"@type":"ImageObject","url":"https://mikezom.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://mikezom.github.io/ accesskey=h title="Wandering in Dreams (Alt + H)">Wandering in Dreams</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">2025 07 02 鸟群行为模拟</h1><div class=post-meta><span title='2025-07-01 00:23:34 +0800 +0800'>July 1, 2025</span>&nbsp;·&nbsp;6 min</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#%e6%b6%8c%e7%8e%b0%e5%bc%8f%e7%be%a4%e4%bd%93%e8%a1%8c%e4%b8%ba%e6%a8%a1%e6%8b%9f aria-label=涌现式群体行为模拟>涌现式群体行为模拟</a><ul><li><a href=#%e7%ae%97%e6%b3%95%e9%80%bb%e8%be%91 aria-label=算法逻辑>算法逻辑</a><ul><li><a href=#%e8%a7%84%e5%88%99%e4%b8%80cohesion-%e5%90%91%e7%be%a4%e4%bd%93%e4%b8%ad%e5%bf%83%e9%9d%a0%e6%8b%a2 aria-label="规则一：Cohesion, 向群体中心靠拢">规则一：Cohesion, 向群体中心靠拢</a></li><li><a href=#%e8%a7%84%e5%88%99%e4%ba%8cseparation-%e9%81%bf%e5%85%8d%e4%b8%8e%e5%90%8c%e4%bc%b4%e7%a2%b0%e6%92%9e aria-label="规则二：Separation, 避免与同伴碰撞">规则二：Separation, 避免与同伴碰撞</a></li><li><a href=#%e8%a7%84%e5%88%99%e4%b8%89alignment-%e4%b8%8e%e5%90%8c%e4%bc%b4%e7%a7%bb%e5%8a%a8%e6%96%b9%e5%90%91%e4%bf%9d%e6%8c%81%e4%b8%80%e8%87%b4 aria-label="规则三：Alignment, 与同伴移动方向保持一致。">规则三：Alignment, 与同伴移动方向保持一致。</a></li></ul></li><li><a href=#%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0 aria-label=算法实现>算法实现</a></li></ul></li></ul></div></details></div><div class=post-content><h1 id=涌现式群体行为模拟>涌现式群体行为模拟<a hidden class=anchor aria-hidden=true href=#涌现式群体行为模拟>#</a></h1><p>link: <a href=https://www.bilibili.com/video/BV1XgM1zQEF5/>【游戏开发秘籍】用算法让NPC集体“开窍”？Boids鸟群算法详解！</a></p><p>鱼群、人群、蜂群等的自然模拟，使用Boids算法。</p><h2 id=算法逻辑>算法逻辑<a hidden class=anchor aria-hidden=true href=#算法逻辑>#</a></h2>$$
\vec{V} = \Pi c_i \vec{v_i}
$$<p>其中，\(\vec{V}\)为最终向量，\(c_i\)为可调权重，\(\vec{v_i}\)为单规则向量。</p><p>我们有以下3条规则：</p><h3 id=规则一cohesion-向群体中心靠拢>规则一：Cohesion, 向群体中心靠拢<a hidden class=anchor aria-hidden=true href=#规则一cohesion-向群体中心靠拢>#</a></h3><p>目标：保持群体集聚。</p><p>行为：计算特定范围（通常为<strong>视野范围</strong>）内<strong>同伴</strong>的<strong>平均位置</strong>，然后产生一个朝向这个平均位置的驱动力。</p><h3 id=规则二separation-避免与同伴碰撞>规则二：Separation, 避免与同伴碰撞<a hidden class=anchor aria-hidden=true href=#规则二separation-避免与同伴碰撞>#</a></h3><p>目标：避免碰撞。</p><p>行为：对于每一个过近的同伴，产生一个排斥力，将这些排斥力加总。</p><h3 id=规则三alignment-与同伴移动方向保持一致>规则三：Alignment, 与同伴移动方向保持一致。<a hidden class=anchor aria-hidden=true href=#规则三alignment-与同伴移动方向保持一致>#</a></h3><p>目标：与群体行动方向趋同。</p><p>行为：计算特定范围（通常为<strong>视野范围</strong>）内<strong>同伴</strong>的<strong>平均方向</strong>，然后调整方向来匹配平均方向。</p><h2 id=算法实现>算法实现<a hidden class=anchor aria-hidden=true href=#算法实现>#</a></h2><p><img alt=Figure loading=lazy src=/posts/2025-07-01-emergence-group-behavior/images/birds.png></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> numpy <span style=color:#66d9ef>as</span> np
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> random
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> matplotlib.pyplot <span style=color:#66d9ef>as</span> plt
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> math
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> statistics
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> pygame
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>MAX_SPEED <span style=color:#f92672>=</span> <span style=color:#ae81ff>10.0</span>
</span></span><span style=display:flex><span>WEIGHT_COHESION <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>WEIGHT_SEPARATION <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>WEIGHT_ALIGNMENT <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>WEIGHT_FORCE_AGAINST_WALL <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>SOCIAL_DISTANCE <span style=color:#f92672>=</span> <span style=color:#ae81ff>20.0</span>
</span></span><span style=display:flex><span>FRAMERATE <span style=color:#f92672>=</span> <span style=color:#ae81ff>30</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>GRAY <span style=color:#f92672>=</span> (<span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>127</span>, <span style=color:#ae81ff>127</span>)
</span></span><span style=display:flex><span>WHITE <span style=color:#f92672>=</span> (<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>255</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>cart2pol</span>(x, y):
</span></span><span style=display:flex><span>    rho <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>sqrt(x<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> y<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    phi <span style=color:#f92672>=</span> math<span style=color:#f92672>.</span>degrees(np<span style=color:#f92672>.</span>arctan2(y, x))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>((phi <span style=color:#f92672>+</span> <span style=color:#ae81ff>360</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>360</span>, rho)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pol2cart</span>(phi, rho):
</span></span><span style=display:flex><span>    x <span style=color:#f92672>=</span> rho <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>cos(math<span style=color:#f92672>.</span>radians(phi))
</span></span><span style=display:flex><span>    y <span style=color:#f92672>=</span> rho <span style=color:#f92672>*</span> np<span style=color:#f92672>.</span>sin(math<span style=color:#f92672>.</span>radians(phi))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span>(x, y)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>EmergenceBehaviorDemo</span>:
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Unit</span>:
</span></span><span style=display:flex><span>        x <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>        y <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>        phi: float
</span></span><span style=display:flex><span>        v <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.0</span>
</span></span><span style=display:flex><span>        i: int
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, i):
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>i <span style=color:#f92672>=</span> i
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Playground</span>:
</span></span><span style=display:flex><span>        w <span style=color:#f92672>=</span> <span style=color:#ae81ff>1280.0</span>
</span></span><span style=display:flex><span>        h <span style=color:#f92672>=</span> <span style=color:#ae81ff>720.0</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    unit_index: int
</span></span><span style=display:flex><span>    peasants: list[Unit]
</span></span><span style=display:flex><span>    playground: Playground
</span></span><span style=display:flex><span>    leader_id: int
</span></span><span style=display:flex><span>    leader_walk_weight_of_previous_tick: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>0.6</span>
</span></span><span style=display:flex><span>    plot_x: list[float]
</span></span><span style=display:flex><span>    plot_y: list[float]
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>init_peasants</span>(self, group_grid_width: int, playground: Playground, interval: float) <span style=color:#f92672>-&gt;</span> list[Unit]:
</span></span><span style=display:flex><span>        <span style=color:#75715e># Generate at the center of the playground</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Center</span>:
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> playground<span style=color:#f92672>.</span>w<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>            y <span style=color:#f92672>=</span> playground<span style=color:#f92672>.</span>h<span style=color:#f92672>/</span><span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>StartingCoord</span>:
</span></span><span style=display:flex><span>            x <span style=color:#f92672>=</span> Center<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> ((group_grid_width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> interval <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            y <span style=color:#f92672>=</span> Center<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> ((group_grid_width <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>*</span> interval <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>unit_index <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        peasants <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(group_grid_width):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> j <span style=color:#f92672>in</span> range(group_grid_width):
</span></span><span style=display:flex><span>                new_unit <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>Unit(self<span style=color:#f92672>.</span>unit_index)
</span></span><span style=display:flex><span>                new_unit<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> StartingCoord<span style=color:#f92672>.</span>x <span style=color:#f92672>+</span> (interval <span style=color:#f92672>*</span> i)
</span></span><span style=display:flex><span>                new_unit<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> StartingCoord<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> (interval <span style=color:#f92672>*</span> j)
</span></span><span style=display:flex><span>                new_unit<span style=color:#f92672>.</span>phi <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>random() <span style=color:#f92672>*</span> <span style=color:#ae81ff>360</span>
</span></span><span style=display:flex><span>                peasants<span style=color:#f92672>.</span>append(new_unit)
</span></span><span style=display:flex><span>                self<span style=color:#f92672>.</span>unit_index <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> peasants
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>            
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_peasants_coordinates</span>(cls, l:list[Unit]):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> unit <span style=color:#f92672>in</span> l:
</span></span><span style=display:flex><span>            print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Peasant </span><span style=color:#e6db74>{</span>unit<span style=color:#f92672>.</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>: (</span><span style=color:#e6db74>{</span>unit<span style=color:#f92672>.</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>unit<span style=color:#f92672>.</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>), v = </span><span style=color:#e6db74>{</span>unit<span style=color:#f92672>.</span>v<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>print_peasant_coordinates</span>(cls, u:Unit):
</span></span><span style=display:flex><span>        print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;Peasant </span><span style=color:#e6db74>{</span>u<span style=color:#f92672>.</span>i<span style=color:#e6db74>}</span><span style=color:#e6db74>: (</span><span style=color:#e6db74>{</span>u<span style=color:#f92672>.</span>x<span style=color:#e6db74>}</span><span style=color:#e6db74>, </span><span style=color:#e6db74>{</span>u<span style=color:#f92672>.</span>y<span style=color:#e6db74>}</span><span style=color:#e6db74>), phi = </span><span style=color:#e6db74>{</span>u<span style=color:#f92672>.</span>phi<span style=color:#e6db74>}</span><span style=color:#e6db74>° v = </span><span style=color:#e6db74>{</span>u<span style=color:#f92672>.</span>v<span style=color:#e6db74>}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update_position</span>(cls, u: Unit, p: Playground):
</span></span><span style=display:flex><span>        u<span style=color:#f92672>.</span>x <span style=color:#f92672>+=</span> u<span style=color:#f92672>.</span>v <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>cos(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi)) 
</span></span><span style=display:flex><span>        u<span style=color:#f92672>.</span>y <span style=color:#f92672>+=</span> u<span style=color:#f92672>.</span>v <span style=color:#f92672>*</span> math<span style=color:#f92672>.</span>sin(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi))
</span></span><span style=display:flex><span>        u<span style=color:#f92672>.</span>x <span style=color:#f92672>=</span> u<span style=color:#f92672>.</span>x <span style=color:#f92672>%</span> p<span style=color:#f92672>.</span>w
</span></span><span style=display:flex><span>        u<span style=color:#f92672>.</span>y <span style=color:#f92672>=</span> u<span style=color:#f92672>.</span>y <span style=color:#f92672>%</span> p<span style=color:#f92672>.</span>h
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>point_in_triangle</span>(cls, p, t_1, t_2, t_3):
</span></span><span style=display:flex><span>        <span style=color:#75715e># https://stackoverflow.com/questions/2049582/how-to-determine-if-a-point-is-in-a-2d-triangle</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>sign</span>(p_1, p_2, p_3):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> (p_1[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> p_3[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>*</span> (p_2[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p_3[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>-</span> (p_2[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> p_3[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>*</span> (p_1[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p_3[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        d1 <span style=color:#f92672>=</span> sign(p, t_1, t_2)
</span></span><span style=display:flex><span>        d2 <span style=color:#f92672>=</span> sign(p, t_2, t_3)
</span></span><span style=display:flex><span>        d3 <span style=color:#f92672>=</span> sign(p, t_3, t_1)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        has_neg <span style=color:#f92672>=</span> (d1 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>or</span> (d2 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>or</span> (d3 <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        has_pos <span style=color:#f92672>=</span> (d1 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>or</span> (d2 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>or</span> (d3 <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>not</span> (has_neg <span style=color:#f92672>and</span> has_pos)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_distance</span>(cls, p1, p2):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> math<span style=color:#f92672>.</span>sqrt((p1[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>-</span> p2[<span style=color:#ae81ff>0</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (p1[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> p2[<span style=color:#ae81ff>1</span>])<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_all_unit_in_eye_sight</span>(self, u: Unit, fov: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>90.0</span>, social_distance: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>20.0</span>, view_distance: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>300.0</span>) <span style=color:#f92672>-&gt;</span> list[Unit]:
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        vertex_1 <span style=color:#f92672>=</span> (u<span style=color:#f92672>.</span>x, u<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>        vertex_2 <span style=color:#f92672>=</span> (u<span style=color:#f92672>.</span>x <span style=color:#f92672>+</span> math<span style=color:#f92672>.</span>cos(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi<span style=color:#f92672>+</span>(fov <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>))) <span style=color:#f92672>*</span> view_distance, u<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> math<span style=color:#f92672>.</span>sin(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi<span style=color:#f92672>+</span>(fov <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>))) <span style=color:#f92672>*</span> view_distance)
</span></span><span style=display:flex><span>        vertex_3 <span style=color:#f92672>=</span> (u<span style=color:#f92672>.</span>x <span style=color:#f92672>+</span> math<span style=color:#f92672>.</span>cos(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi<span style=color:#f92672>-</span>(fov <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>))) <span style=color:#f92672>*</span> view_distance, u<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> math<span style=color:#f92672>.</span>sin(math<span style=color:#f92672>.</span>radians(u<span style=color:#f92672>.</span>phi<span style=color:#f92672>-</span>(fov <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>))) <span style=color:#f92672>*</span> view_distance)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Now we have one triangle</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> peasant <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> peasant<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> u<span style=color:#f92672>.</span>i:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>point_in_triangle((peasant<span style=color:#f92672>.</span>x, peasant<span style=color:#f92672>.</span>y), vertex_1, vertex_2, vertex_3) <span style=color:#f92672>or</span> self<span style=color:#f92672>.</span>get_distance((u<span style=color:#f92672>.</span>x, u<span style=color:#f92672>.</span>y), (peasant<span style=color:#f92672>.</span>x, peasant<span style=color:#f92672>.</span>y)) <span style=color:#f92672>&lt;=</span> social_distance:
</span></span><span style=display:flex><span>                res<span style=color:#f92672>.</span>append(peasant)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>get_all_unit_nearby</span>(self, u: Unit, fov: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>90.0</span>, social_distance: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>50.0</span>, view_distance: float <span style=color:#f92672>=</span> <span style=color:#ae81ff>300.0</span>) <span style=color:#f92672>-&gt;</span> list[Unit]:
</span></span><span style=display:flex><span>        res <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Now we have one triangle</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> peasant <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> peasant<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> u<span style=color:#f92672>.</span>i:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>get_distance((u<span style=color:#f92672>.</span>x, u<span style=color:#f92672>.</span>y), (peasant<span style=color:#f92672>.</span>x, peasant<span style=color:#f92672>.</span>y)) <span style=color:#f92672>&lt;=</span> social_distance:
</span></span><span style=display:flex><span>                res<span style=color:#f92672>.</span>append(peasant)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> res
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>combine_force_list</span>(cls, l_force: list, l_weight: list <span style=color:#f92672>=</span> []):
</span></span><span style=display:flex><span>        final_force_cart <span style=color:#f92672>=</span> [<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> len(l_weight) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>            actual_weight <span style=color:#f92672>=</span> [<span style=color:#ae81ff>1</span>] <span style=color:#f92672>*</span> len(l_force)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>            actual_weight <span style=color:#f92672>=</span> l_weight
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(len(l_force)):
</span></span><span style=display:flex><span>            (x, y) <span style=color:#f92672>=</span> pol2cart(l_force[i][<span style=color:#ae81ff>0</span>], l_force[i][<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>            final_force_cart[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>+=</span> x <span style=color:#f92672>*</span> actual_weight[i]
</span></span><span style=display:flex><span>            final_force_cart[<span style=color:#ae81ff>1</span>] <span style=color:#f92672>+=</span> y <span style=color:#f92672>*</span> actual_weight[i]
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        final_force_rad <span style=color:#f92672>=</span> cart2pol(final_force_cart[<span style=color:#ae81ff>0</span>], final_force_cart[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> final_force_rad
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>distance_between_point_and_line</span>(cls, _lv1, _lv2, _p):
</span></span><span style=display:flex><span>        lv1 <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(_lv1)
</span></span><span style=display:flex><span>        lv2 <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(_lv2)
</span></span><span style=display:flex><span>        p <span style=color:#f92672>=</span> np<span style=color:#f92672>.</span>array(_p)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> np<span style=color:#f92672>.</span>abs(np<span style=color:#f92672>.</span>cross(lv2<span style=color:#f92672>-</span>lv1, lv1<span style=color:#f92672>-</span>p)) <span style=color:#f92672>/</span> np<span style=color:#f92672>.</span>linalg<span style=color:#f92672>.</span>norm(lv2<span style=color:#f92672>-</span>lv1)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@classmethod</span>  
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>force_against_the_walls</span>(cls, u: Unit, p: Playground):
</span></span><span style=display:flex><span>        v1 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0.0</span>, <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>        v2 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0.0</span>, p<span style=color:#f92672>.</span>h)
</span></span><span style=display:flex><span>        v3 <span style=color:#f92672>=</span> (p<span style=color:#f92672>.</span>w, <span style=color:#ae81ff>0.0</span>)
</span></span><span style=display:flex><span>        v4 <span style=color:#f92672>=</span> (p<span style=color:#f92672>.</span>w, p<span style=color:#f92672>.</span>h)
</span></span><span style=display:flex><span>        s <span style=color:#f92672>=</span> (u<span style=color:#f92672>.</span>x, u<span style=color:#f92672>.</span>y)
</span></span><span style=display:flex><span>        c <span style=color:#f92672>=</span> <span style=color:#ae81ff>200.0</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wall 1 v1-v2</span>
</span></span><span style=display:flex><span>        d1 <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>distance_between_point_and_line(v1, v2, s)
</span></span><span style=display:flex><span>        f1 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>90.0</span>, c <span style=color:#f92672>/</span> d1)
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wall 2 v1-v3</span>
</span></span><span style=display:flex><span>        d2 <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>distance_between_point_and_line(v1, v3, s)
</span></span><span style=display:flex><span>        f2 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>180.0</span>, c <span style=color:#f92672>/</span> d2)
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wall 3 v4-v2</span>
</span></span><span style=display:flex><span>        d3 <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>distance_between_point_and_line(v4, v2, s)
</span></span><span style=display:flex><span>        f3 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0.0</span>, c <span style=color:#f92672>/</span> d3)
</span></span><span style=display:flex><span>        <span style=color:#75715e># Wall 4 v4-v3</span>
</span></span><span style=display:flex><span>        d4 <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>distance_between_point_and_line(v4, v3, s)
</span></span><span style=display:flex><span>        f4 <span style=color:#f92672>=</span> (<span style=color:#ae81ff>270.0</span>, c <span style=color:#f92672>/</span> d4)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        force_against_the_walls_list <span style=color:#f92672>=</span> [f1, f2, f3, f4]
</span></span><span style=display:flex><span>        force_against_the_walls <span style=color:#f92672>=</span> cls<span style=color:#f92672>.</span>combine_force_list(force_against_the_walls_list)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> force_against_the_walls
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>find_peasant_with_id</span>(self, i):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> u<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> i: <span style=color:#66d9ef>return</span> u
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>raise</span> <span style=color:#a6e22e>Exception</span>(<span style=color:#e6db74>&#39;no such id&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>update_behavior</span>(
</span></span><span style=display:flex><span>        self, 
</span></span><span style=display:flex><span>        cohesion_weight: float <span style=color:#f92672>=</span> WEIGHT_COHESION, 
</span></span><span style=display:flex><span>        separation_weight: float <span style=color:#f92672>=</span> WEIGHT_SEPARATION,
</span></span><span style=display:flex><span>        social_distance: float <span style=color:#f92672>=</span> SOCIAL_DISTANCE, 
</span></span><span style=display:flex><span>        alignment_weight: float <span style=color:#f92672>=</span> WEIGHT_ALIGNMENT,
</span></span><span style=display:flex><span>        force_against_wall_weight: float <span style=color:#f92672>=</span> WEIGHT_FORCE_AGAINST_WALL
</span></span><span style=display:flex><span>    ):
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        new_direction_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> peasant <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            peasants_in_view <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_all_unit_in_eye_sight(peasant)
</span></span><span style=display:flex><span>            peasants_nearby <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>get_all_unit_nearby(peasant)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e># Calculate cohesion</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(peasants_nearby) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                cohesion_force <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                average_position_in_view <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>                    statistics<span style=color:#f92672>.</span>mean(map(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>x, peasants_nearby)),
</span></span><span style=display:flex><span>                    statistics<span style=color:#f92672>.</span>mean(map(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>y, peasants_nearby))
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                (xs, ys) <span style=color:#f92672>=</span> pol2cart(peasant<span style=color:#f92672>.</span>phi, peasant<span style=color:#f92672>.</span>v)
</span></span><span style=display:flex><span>                cohesion_force <span style=color:#f92672>=</span> cart2pol((average_position_in_view[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>-</span>xs), (average_position_in_view[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>-</span>ys))
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>            <span style=color:#75715e># Calculate Separation</span>
</span></span><span style=display:flex><span>            separation_force_list <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> u <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> u<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> peasant<span style=color:#f92672>.</span>i:
</span></span><span style=display:flex><span>                    <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> self<span style=color:#f92672>.</span>get_distance((u<span style=color:#f92672>.</span>x, u<span style=color:#f92672>.</span>y), (peasant<span style=color:#f92672>.</span>x, peasant<span style=color:#f92672>.</span>y)) <span style=color:#f92672>&lt;=</span> social_distance:
</span></span><span style=display:flex><span>                    c <span style=color:#f92672>=</span> <span style=color:#f92672>-</span><span style=color:#ae81ff>1</span> <span style=color:#f92672>/</span> math<span style=color:#f92672>.</span>sqrt((u<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> peasant<span style=color:#f92672>.</span>y)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span> <span style=color:#f92672>+</span> (u<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> peasant<span style=color:#f92672>.</span>x)<span style=color:#f92672>**</span><span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>                    (x, y) <span style=color:#f92672>=</span> ((u<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> peasant<span style=color:#f92672>.</span>x) <span style=color:#f92672>*</span> c, (u<span style=color:#f92672>.</span>y <span style=color:#f92672>-</span> peasant<span style=color:#f92672>.</span>y) <span style=color:#f92672>*</span> c)
</span></span><span style=display:flex><span>                    new_force <span style=color:#f92672>=</span> cart2pol(x, y)
</span></span><span style=display:flex><span>                    separation_force_list<span style=color:#f92672>.</span>append(new_force)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(separation_force_list) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                separation_force <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                separation_force <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>combine_force_list(separation_force_list)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e># Calculate Alignment</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> len(peasants_in_view) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>:
</span></span><span style=display:flex><span>                alignment_force <span style=color:#f92672>=</span> (<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                average_movement_in_view <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>                    statistics<span style=color:#f92672>.</span>mean(map(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>phi, peasants_in_view)),
</span></span><span style=display:flex><span>                    statistics<span style=color:#f92672>.</span>mean(map(<span style=color:#66d9ef>lambda</span> x: x<span style=color:#f92672>.</span>v, peasants_in_view))
</span></span><span style=display:flex><span>                )
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                (xt, yt) <span style=color:#f92672>=</span> pol2cart(average_movement_in_view[<span style=color:#ae81ff>0</span>], average_movement_in_view[<span style=color:#ae81ff>1</span>])
</span></span><span style=display:flex><span>                (xs, ys) <span style=color:#f92672>=</span> pol2cart(peasant<span style=color:#f92672>.</span>phi, peasant<span style=color:#f92672>.</span>v)
</span></span><span style=display:flex><span>                
</span></span><span style=display:flex><span>                alignment_force <span style=color:#f92672>=</span> cart2pol((xt<span style=color:#f92672>-</span>xs), (yt<span style=color:#f92672>-</span>ys))
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#75715e># Calculate force against the wall</span>
</span></span><span style=display:flex><span>            force_against_wall <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>force_against_the_walls(peasant, self<span style=color:#f92672>.</span>playground)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            cohesion_force <span style=color:#f92672>=</span> (cohesion_force[<span style=color:#ae81ff>0</span>], cohesion_force[<span style=color:#ae81ff>1</span>]<span style=color:#f92672>**</span><span style=color:#ae81ff>0.75</span>)
</span></span><span style=display:flex><span>            alignment_force <span style=color:#f92672>=</span> (alignment_force[<span style=color:#ae81ff>0</span>], math<span style=color:#f92672>.</span>sqrt(alignment_force[<span style=color:#ae81ff>1</span>]))
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            total_force <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>combine_force_list(
</span></span><span style=display:flex><span>                [cohesion_force, separation_force, alignment_force, force_against_wall],
</span></span><span style=display:flex><span>                [cohesion_weight, separation_weight, alignment_weight, force_against_wall_weight]
</span></span><span style=display:flex><span>            )
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> peasant<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> self<span style=color:#f92672>.</span>leader_id:
</span></span><span style=display:flex><span>                print(<span style=color:#e6db74>f</span><span style=color:#e6db74>&#34;c_force:(</span><span style=color:#e6db74>{</span>cohesion_force[<span style=color:#ae81ff>0</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>°, </span><span style=color:#e6db74>{</span>cohesion_force[<span style=color:#ae81ff>1</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>m/s) s_force:(</span><span style=color:#e6db74>{</span>separation_force[<span style=color:#ae81ff>0</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>°, </span><span style=color:#e6db74>{</span>separation_force[<span style=color:#ae81ff>1</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>m/s) a_force:(</span><span style=color:#e6db74>{</span>alignment_force[<span style=color:#ae81ff>0</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>°, </span><span style=color:#e6db74>{</span>alignment_force[<span style=color:#ae81ff>1</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>m/s) f_force:(</span><span style=color:#e6db74>{</span>force_against_wall[<span style=color:#ae81ff>0</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>°, </span><span style=color:#e6db74>{</span>force_against_wall[<span style=color:#ae81ff>1</span>]<span style=color:#e6db74>:</span><span style=color:#e6db74>.2f</span><span style=color:#e6db74>}</span><span style=color:#e6db74>m/s)&#34;</span>)
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>            new_direction_list<span style=color:#f92672>.</span>append((peasant<span style=color:#f92672>.</span>i, total_force))
</span></span><span style=display:flex><span>            
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (_i, (_phi, _v)) <span style=color:#f92672>in</span> new_direction_list:
</span></span><span style=display:flex><span>            current_peasant <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>peasants[_i]
</span></span><span style=display:flex><span>            current_peasant<span style=color:#f92672>.</span>phi <span style=color:#f92672>=</span> _phi
</span></span><span style=display:flex><span>            current_peasant<span style=color:#f92672>.</span>v <span style=color:#f92672>=</span> min(_v, MAX_SPEED)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> peasant <span style=color:#f92672>in</span> self<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            self<span style=color:#f92672>.</span>update_position(peasant, self<span style=color:#f92672>.</span>playground)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>__init__</span>(self, group_grid_width: int, interval: float):
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>playground <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>Playground()
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>peasants <span style=color:#f92672>=</span> self<span style=color:#f92672>.</span>init_peasants(group_grid_width, self<span style=color:#f92672>.</span>playground, interval)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>leader_id <span style=color:#f92672>=</span> random<span style=color:#f92672>.</span>randint(<span style=color:#ae81ff>0</span>, len(self<span style=color:#f92672>.</span>peasants)<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>plot_x <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        self<span style=color:#f92672>.</span>plot_y <span style=color:#f92672>=</span> []
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>pass</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>pygame_rot_center</span>(image, angle, x, y):
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    rotated_image <span style=color:#f92672>=</span> pygame<span style=color:#f92672>.</span>transform<span style=color:#f92672>.</span>rotate(image, angle)
</span></span><span style=display:flex><span>    new_rect <span style=color:#f92672>=</span> rotated_image<span style=color:#f92672>.</span>get_rect(center <span style=color:#f92672>=</span> image<span style=color:#f92672>.</span>get_rect(center <span style=color:#f92672>=</span> (x, y))<span style=color:#f92672>.</span>center)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> rotated_image, new_rect
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>main</span>():
</span></span><span style=display:flex><span>    run <span style=color:#f92672>=</span> <span style=color:#66d9ef>True</span>
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    game <span style=color:#f92672>=</span> EmergenceBehaviorDemo(<span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>10.0</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pygame<span style=color:#f92672>.</span>init()
</span></span><span style=display:flex><span>    window <span style=color:#f92672>=</span> pygame<span style=color:#f92672>.</span>display<span style=color:#f92672>.</span>set_mode((game<span style=color:#f92672>.</span>playground<span style=color:#f92672>.</span>w, game<span style=color:#f92672>.</span>playground<span style=color:#f92672>.</span>h))
</span></span><span style=display:flex><span>    clock <span style=color:#f92672>=</span> pygame<span style=color:#f92672>.</span>time<span style=color:#f92672>.</span>Clock()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pygame_image_fish <span style=color:#f92672>=</span> pygame<span style=color:#f92672>.</span>image<span style=color:#f92672>.</span>load(<span style=color:#e6db74>&#39;fish.png&#39;</span>)<span style=color:#f92672>.</span>convert_alpha()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> run:
</span></span><span style=display:flex><span>        clock<span style=color:#f92672>.</span>tick(FRAMERATE)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> event <span style=color:#f92672>in</span> pygame<span style=color:#f92672>.</span>event<span style=color:#f92672>.</span>get():
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> event<span style=color:#f92672>.</span>type <span style=color:#f92672>==</span> pygame<span style=color:#f92672>.</span>QUIT:
</span></span><span style=display:flex><span>                run <span style=color:#f92672>=</span> <span style=color:#66d9ef>False</span>
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        game<span style=color:#f92672>.</span>update_behavior()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        window<span style=color:#f92672>.</span>fill(GRAY)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> peasant <span style=color:#f92672>in</span> game<span style=color:#f92672>.</span>peasants:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> peasant<span style=color:#f92672>.</span>i <span style=color:#f92672>==</span> game<span style=color:#f92672>.</span>leader_id:
</span></span><span style=display:flex><span>                pygame<span style=color:#f92672>.</span>draw<span style=color:#f92672>.</span>rect(window, WHITE, (peasant<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>, peasant<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>10</span>, <span style=color:#ae81ff>10</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                rotated_image, new_rect <span style=color:#f92672>=</span> pygame_rot_center(pygame_image_fish, (peasant<span style=color:#f92672>.</span>phi <span style=color:#f92672>+</span> <span style=color:#ae81ff>270</span>) <span style=color:#f92672>%</span> <span style=color:#ae81ff>360</span>, peasant<span style=color:#f92672>.</span>x <span style=color:#f92672>-</span> <span style=color:#ae81ff>5</span>, peasant<span style=color:#f92672>.</span>y <span style=color:#f92672>+</span> <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>                window<span style=color:#f92672>.</span>blit(rotated_image, new_rect)
</span></span><span style=display:flex><span>        pygame<span style=color:#f92672>.</span>display<span style=color:#f92672>.</span>flip()
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>plot(game<span style=color:#f92672>.</span>plot_x, game<span style=color:#f92672>.</span>plot_y, color<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;blue&#39;</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>grid(<span style=color:#66d9ef>True</span>)
</span></span><span style=display:flex><span>    plt<span style=color:#f92672>.</span>savefig(<span style=color:#e6db74>&#39;foo.png&#39;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    pygame<span style=color:#f92672>.</span>quit()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>main()
</span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://mikezom.github.io/>Wandering in Dreams</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>